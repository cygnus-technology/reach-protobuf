
/*
 * Copyright (c) 2023-2024 i3 Product Development
 * 
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// Protobuf definition of the Reach protocol

syntax = "proto3";

package cr;

/** C# namespace for generated classes. */
option csharp_namespace = "Cygnus.Reach";

/** Java package for generated classes. */
option java_multiple_files = true;
option java_package = "com.cygnusreach.reachprotocol.proto";

/** Swift options */
option swift_prefix = "";

// ReachProtoVersion is replaced by the MAJOR, MINOR and PATCH, below.
    // 5: device info extended with sizes structure
    // 6: device info entries made redundant by sizes are deleted.
    // 7: Added file erase and time service
    // 10: Skipped up to make incompatible change to BufferSizes
    // 11: Changes to improve the compatibility of v10
    // 12: Renamed "reply" messages as "response" messages.
    // 13: Restored param_info_enum_count
    // 14: Adding WiFi service
    // 15: 32 character challenge key
    // 16: Replaced number_of_objects; with client_id
    // 17: Add description and timeout to CommandInfo
    // 18: Generalize device description len to description len
    // 19: Remove parameter key
    // 20: Added protocol_version_string, deprecated protocol_version.
    // 21: Added separate version numbers for MAJOR, MINOR and PATCH.
    // 0x101:  starting on ahsoka changes
    // 0x102:  merging 676 into ahsoka
    // 0x103:  Reworked FileTransfer start with checksum and preferred ack rate.
    // 0x104:  Added discover notifications.
    // 0x105:  Renamed discover notifications.
    // 0x106:  Changed CONFIG_PARAM_NOTIFY handling to expect an array of up to 8.
    // 0x107:  Replaced CONFIG_PARAM_NOTIFY with ENABLE and DISABLE
    // 0x108:  Removed and reserved obsolete messages_per_ack
    // 0.2.1:  Unionzed Parameter Descriptions
    // 0.2.2:  File erase, removed integer proto version

/// The major version generally changes to signal a break in compatibility
enum ReachProto_MAJOR_Version {
    // MAJOR_V0       = 0;   // Must have a zero
    MAJOR_VERSION  = 0;
}
/// The minor version changes at a release which is not completely compatible
enum ReachProto_MINOR_Version {
    MINOR_V0       = 0;   ///< Must have a zero
    MINOR_VERSION  = 2;   ///< Update at a release or a big change
}
/// The patch version changes every time a hex file goes out the door.
enum ReachProto_PATCH_Version {
  PATCH_V0         = 0;   ///< Must have a zero
  PATCH_VERSION    = 2;   ///< Update when something changes
}

/// These values identify the type of the Reach message.
enum ReachMessageTypes {
  reserved  9;  // obsolete CONFIG_PARAM_NOTIFY
  INVALID                     = 0;   ///< No Valid Message
  ERROR_REPORT                = 1;   ///< Inform client of an error condition
  PING                        = 2;   ///< Test the link to the server
  GET_DEVICE_INFO             = 3;   ///< Open the communication with a server

  /// Parameters
  DISCOVER_PARAMETERS         = 5;   ///< Get a list of all of the parameters in the repository
  DISCOVER_PARAM_EX           = 6;   ///< An extension to discover used by verbose parameters
  READ_PARAMETERS             = 7;   ///< Get the values of a set of parameters
  WRITE_PARAMETERS            = 8;   ///< Change the values of a set of parameters
  PARAMETER_NOTIFICATION   =   10;   ///< Sent from the server to the client when a parameter has changed
  DISCOVER_NOTIFICATIONS   =   11;   ///< Find out how notifications are setup
  PARAM_ENABLE_NOTIFY      =   50;   ///< setup parameter notifications
  PARAM_DISABLE_NOTIFY     =   51;   ///< disable parameter notifications

  /// File Transfers
  DISCOVER_FILES              = 12;  ///< Get a list of supported files
  TRANSFER_INIT               = 13;  ///< Begin a file transfer
  TRANSFER_DATA               = 14;  ///< (bi-directional) sends the requested data 
  TRANSFER_DATA_NOTIFICATION  = 15;  ///< (bi-directional) Clears Sender to Send More Data
  ERASE_FILE                  = 16;  ///< Set file size to zero.

  /// Commands
  DISCOVER_COMMANDS           = 17;  ///< Get a list of supported commands
  SEND_COMMAND                = 18;  ///< Reqeuest excecution of a command

  // Command Line Interface
  CLI_NOTIFICATION            = 20;  ///< Inform the other side (bi-directional) of a command line.

  // Streams
  DISCOVER_STREAMS            = 25;  ///< Get a list of supported streams
  OPEN_STREAM                 = 26;  ///< Open a stream
  CLOSE_STREAM                = 27;  ///< Close a stream
  STREAM_DATA_NOTIFICATION    = 28;  ///< Inform the other side (bi-directional) of data on a stream.

  // Time
  SET_TIME                    = 30;  ///< Set the real time clock
  GET_TIME                    = 31;  ///< Read the real time clock

  // WiFi
  DISCOVER_WIFI               = 40;  ///< Get a list of WiFi acces points
  WIFI_CONNECT                = 41;  ///< Connect or disconnect to an access point
}

/// This is the "classic" Reach service routing message header.  
/// It is now deprecated in favor of the AhsokaMessageHeader.
message ReachMessageHeader {
  uint32 message_type         = 1;  ///< This ID defines the Type of Message being carried in the Envelope / Header
  uint32 endpoint_id          = 2;  ///< Routing for endpoints other than zero.
  uint32 client_id            = 3;  ///< To support multiple clients
  uint32 remaining_objects    = 4;  ///< Zero when transaction is complete
  uint32 transaction_id       = 5;  ///< An ID for a series of messages
}

/// A reach packet includes a header and a payload.
message ReachMessage {
  ReachMessageHeader header = 1;  ///< A routing header
  bytes payload = 2;              ///< The encoded payload
}

/// This Service Routing Message Header is used in the OpenPV system.
/// Reach can speak it.
/// This object represents the Layer 2 Message Format for OpenPV Service Messages.
/// The ordinals are presereved but the names are changed to match 
message AhsokaMessageHeader
{
    /// This ID defines the Type of Message being carried in the Envelope / Header
    /// Called transport_id in OpenPV terminology.
    /// Called message_type in Reach terms.
    int32 message_type = 1;

    /// This ID defines a unique Message / Response used when out of order messages are needed
    /// Called transaction_id in the OpenPV system.
    /// Called transaction_id in Reach terms.
    int32 transaction_id = 2;

    /// Unique ID for a Client used in Services that support Multiple Clients 
    // OpenPV would use a GUID but Reach uses a 4 byte integer
    bytes client_id = 3;

    /// Called message_size in the OpenPV system.
    /// Called remaining_objects in Reach terms
    /// In Reach it defines the number of objects that remain to be 
    /// transmitted in a continuued transaction.
    /// The size of the message payload (in packets) that follows this header
    int32 remaining_objects  = 4;

    // Routing for Non-Endpoint Style Transports. 
    // Note: Endpoint 0 is Reserved for Service Discovery for Non-Endpoint Transports
    uint32 endpoint_id = 5;

    /// Not used or supported in Reach.  
    /// In OpenPV, indicates that the message has used deflate compression in addition to pbuff encoding
    bool is_message_compressed = 6;
}

/// ERROR_REPORT: Could be sent asynchronously to indicate an error.
message ErrorReport {
  int32  result            = 1;    ///< The integer error code being reported, preferrably from the ErrorCodes enum.
  string result_message    = 2;    ///< A human readable string describing the error.
}

/// Request Object used to Echo Data for testing the Device Communication
message PingRequest {
  bytes echo_data         = 1;    ///< Data which should be echoed in the response
}

/// Response Object used to Echo Data for testing the Device Communication
message PingResponse {
  bytes echo_data         = 1;   ///< The same data sent in the request
  int32 signal_strength   = 2;   ///< rssi : The server's received signal strength expressed in dB.
}

/// Required Device Information Service
/// Reach sessions are opened with the device info request and response.  
message DeviceInfoRequest {
  optional string challenge_key  = 1;  ///< The request can include a challenge key to grant or deny access to parts of the system.
  string client_protocol_version = 2;  ///< The client shares its version to enable backward compatibility.
}

/// This message is returned in answer to the first "who are you" query from the client.
message DeviceInfoResponse {
  reserved 1; // deprecated protocol_version as an integer
  string device_name              = 2;    ///< Human readable name of the device
  string manufacturer             = 3;    ///< Human readable name of the manufacturer
  string device_description       = 4;    ///< A longer human readable description.
  /// Each endpoint advertises a "main" FW version.
  /// If there are other FW versions, put them in the parameter repo.
  string firmware_version         = 6;
  string protocol_version_string  = 7;    ///< The protocol version as a string against which this device is built.
  uint32 services                 = 8;    ///< A bit mask, allowing support for up to 32 services
  uint32 parameter_metadata_hash  = 9;    ///< Used to avoid reloading the parameter descriptions
  optional bytes application_identifier = 10;   ///< A UUID to find a custom user interface
  uint32 endpoints                      = 11;   ///< A bit mask, non-zero if the device supports more than one endpoint.
  bytes sizes_struct = 20;  ///< A packed structure informing the client of the size limitations of the server. See SizesOffsets for descriptions.
}

/// binary bit masks or'ed together into the DeviceInfoResponse.services
enum ServiceIds {
  NO_SVC_ID       = 0;  ///< No services.  Device info service is required.
  PARAMETER_REPO  = 1;  ///< Set this bit when the device supports the parameter service
  FILES           = 2;  ///< Set this bit when the device supports the file service
  STREAMS         = 4;  ///< Set this bit when the device supports the stream service
  COMMANDS        = 8;  ///< Set this bit when the device supports the command service
  CLI             = 16; ///< Set this bit when the device supports the command line interface
  TIME            = 32; ///< Set this bit when the device supports the time service
  WIFI            = 64; ///< Set this bit when the device supports the WiFi service
}

/// binary bit masks or'ed together into the DeviceInfoResponse.endpoints
enum EndpointIds { 
  NO_ENDPOINTS    = 0;  ///< No other endpoints
  ONE             = 1;  ///< This is the first of multiple endpoints.
  TWO             = 2;  ///< This is the second of multiple endpoints. 
  THREE           = 4;  ///< This is the third of multiple endpoints.
  FOUR            = 8;  ///< This is the fourth of multiple endpoints.
}

/// 
/// Parameter Service
/// Parameters provide a simple key:value database. The key is an ID number.  
/// The value can be of various common types up to (typically) 32 bytes.  
/// Parameters support a robust description which can be const, stored in flash.  
/// Parameters can be configured to support notifying the client.
/// 
/// The ParameterInfoRequest is used by the client to request detailed information
/// about a set of parameters.
message ParameterInfoRequest {
  repeated uint32 parameter_ids = 2; ///< ID's to Fetch (Empty to Get All)
}

/// The response to ParameterInfoRequest
message ParameterInfoResponse {
  repeated ParameterInfo parameter_infos = 1; ///< An array of Param Info structures
}

/// A member of a union (oneof) that describes a uint32
message Uint32ParameterInfo {
  optional uint32 range_min = 1;      ///< The (optional) minimum value for this parameter.
  optional uint32 range_max = 2;      ///< The (optional) minimum value for this parameter.
  optional uint32 default_value = 3;  ///< The (optional) default value for this parameter.
  optional string units = 4;          ///< A string (UTF-8) to be displayed as the units of the parameter.
}
/// A member of a union (oneof) that describes an sint32
message Int32ParameterInfo {
  optional int32 range_min = 1;       ///< The (optional) minimum value for this parameter.                 
  optional int32 range_max = 2;       ///< The (optional) minimum value for this parameter.                 
  optional int32 default_value = 3;   ///< The (optional) default value for this parameter.                 
  optional string units = 4;          ///< A string (UTF-8) to be displayed as the units of the parameter. 
}
/// A member of a union (oneof) that describes a float32
message Float32ParameterInfo {
  optional float range_min = 1;       ///< The (optional) minimum value for this parameter.                 
  optional float range_max = 2;       ///< The (optional) minimum value for this parameter.                 
  optional float default_value = 3;   ///< The (optional) default value for this parameter.                 
  optional uint32 precision = 4;      ///< How many digits to be displayed to the right of the decimal point.
  optional string units = 5;          ///< A string (UTF-8) to be displayed as the units of the parameter. 
}
/// A member of a union (oneof) that describes a uint64
message Uint64ParameterInfo {
  optional uint64 range_min = 1;      ///< The (optional) minimum value for this parameter.                  
  optional uint64 range_max = 2;      ///< The (optional) minimum value for this parameter.                  
  optional uint64 default_value = 3;  ///< The (optional) default value for this parameter.                  
  optional string units = 4;          ///< A string (UTF-8) to be displayed as the units of the parameter.  
}
/// A member of a union (oneof) that describes an sint64
message Int64ParameterInfo {
  optional int64 range_min = 1;       ///< The (optional) minimum value for this parameter.                
  optional int64 range_max = 2;       ///< The (optional) minimum value for this parameter.                
  optional int64 default_value = 3;   ///< The (optional) default value for this parameter.                
  optional string units = 4;          ///< A string (UTF-8) to be displayed as the units of the parameter.
}
/// A member of a union (oneof) that describes a float64
message Float64ParameterInfo {
  optional double range_min = 1;      ///< The (optional) minimum value for this parameter.                   
  optional double range_max = 2;      ///< The (optional) minimum value for this parameter.                   
  optional double default_value = 3;  ///< The (optional) default value for this parameter.                   
  optional uint32 precision = 4;      ///< How many digits to be displayed to the right of the decimal point.
  optional string units = 5;          ///< A string (UTF-8) to be displayed as the units of the parameter.   
}
/// A member of a union (oneof) that describes a boolean
message BoolParameterInfo {
  optional bool default_value = 1;    ///< The (optional) default value for this parameter.
  optional uint32 pei_id = 2;         ///< The (optional) ID of the extended description that names the two states.
}
/// A member of a union (oneof) that describes a string
message StringParameterInfo {
  optional string default_value = 1;  ///< The (optional) default value for this parameter..
  uint32 max_size = 2;                ///< The length of the longest string to be stored here.
}
/// A member of a union (oneof) that describes an enumerated value
message EnumParameterInfo {
  optional uint32 range_min = 1;      ///< The (optional) minimum value for this parameter.
  optional uint32 range_max = 2;      ///< The (optional) minimum value for this parameter.
  optional uint32 default_value = 3;  ///< The (optional) default value for this parameter.
  optional uint32 pei_id = 4;         ///< The (optional) ID of the extended description that names the values.
  optional string units = 5;          ///< A string (UTF-8) to be displayed as the units of the parameter.
}
/// A member of a union (oneof) that describes a bitfield
message BitfieldParameterInfo {
  optional uint64 default_value = 1;  ///< The (optional) default value for this parameter.
  uint32 bits_available = 2;          ///< How many bits of this bifield are valid
  optional uint32 pei_id = 3;         ///< The (optional) ID of the extended description that names the bits.
}
/// A member of a union (oneof) that describes a byte array
message ByteArrayParameterInfo {
  optional bytes default_value = 1;   ///< The (optional) default value for this parameter.
  uint32 max_size = 2;                ///< The size in bytes of the largest array to be stored.
}

/// A ParameterInfo structure describes a parameter so that it can be easily viewed an edited 
/// by humans using a generic parameter editor.
message ParameterInfo {
  uint32 id                         = 1;  ///< The integer ID used to reference this parameter.
  string name                       = 2;  ///< A human readable name for this parameter.
  optional string description       = 3;  ///< A longer human readable description of this parameter.
  AccessLevel access                = 4;  ///< Read or write access.  Can be used for access control.
  StorageLocation storage_location  = 5;  ///< RAM or NVM or ?
  oneof desc                                      ///< A union allowing for an appropriate description of each type
  {
    Uint32ParameterInfo    uint32_desc    = 6;    ///< If uint32
    Int32ParameterInfo     int32_desc     = 7;    ///< If sint32
    Float32ParameterInfo   float32_desc   = 8;    ///< If float32
    Uint64ParameterInfo    uint64_desc    = 9;    ///< If uint64
    Int64ParameterInfo     int64_desc     = 10;   ///< If sint64
    Float64ParameterInfo   float64_desc   = 11;   ///< If float64
    BoolParameterInfo      bool_desc      = 12;   ///< If a boolean
    StringParameterInfo    string_desc    = 13;   ///< If a string
    EnumParameterInfo      enum_desc      = 14;   ///< If an enumeated type
    BitfieldParameterInfo  bitfield_desc  = 15;   ///< If a bitfield
    ByteArrayParameterInfo bytearray_desc = 16;   ///< If a byte array
  }
}

/// The ParamExKey is used to give names to enums, bitfields, and booleans.
/// It is typically supplied in an array.
/// More than one parameter can point to the same ParamExKey.
message ParamExKey {
    uint32 id               = 1;  ///< the value of the enum or the bit position of the bitfield
    string name             = 2;  ///< the name of the enum/bit/state
}

/// Describes enum, bitfield, and boolean labels
message ParamExInfoResponse {
    reserved 1; // deleted associated_pid;
    ParameterDataType   data_type      = 2;   ///< The type of data being described.
    repeated ParamExKey keys           = 3;   ///< Each key associates a string with a number
    uint32              pei_id         = 4;   ///< An ID by which this Parameter Extended Information is retrieved.
}

/// A structure used to read one or more parameters
message ParameterRead {
  repeated uint32 parameter_ids = 2;        ///< An array of parameters to be read, or empty to Retrieve All
}

/// A structure used to return the values read from one or more parameters
message ParameterReadResponse {
  repeated ParameterValue values  = 3;      ///< An array of Result Values
}

/// A structure used to write one or more Parameters
message ParameterWrite {
  repeated ParameterValue values  = 3;      ///< An array of Write Values
}

/// The response to a parameter write
message ParameterWriteResponse {
  int32 result                    = 1;      ///< A result of zero indicates OK
  optional string result_message  = 2;      ///< Allows to provide a human readable explanation in case of an error.
}

/// Parameter Notification configuration
/// Notification can be enabled with conditions for each parameter.
message ParameterNotifyConfig {
  uint32 parameter_id                = 1;    ///< Which param to configure
  uint32 minimum_notification_period = 2;    ///< min_ms: Minimum Notification Interval (ms)
  uint32 maximum_notification_period = 3;    ///< max_ms: Minimum Notification Interval (ms)
  float  minimum_delta               = 4;    ///< notify only if change by this much
}

/// A message used to enable notifications
message ParameterEnableNotifications {
  repeated ParameterNotifyConfig  configs = 1;  ///< An array of descriptions of notifications
  bool     disable_all_first              = 2;  ///< If true, all notifications are disabled before applying the new request.
}                                         

/// A message used to disable notifications
message ParameterDisableNotifications {
  repeated uint32 parameter_ids           = 1;  ///< An array of parameter ID's to be disabled.
}                                         

/// The response to enable and disable notifications
message ParameterNotifyConfigResponse {
  int32  result                       = 1;      ///< A result of zero indicates OK                                       
  optional string result_message      = 2;      ///< Allows to provide a human readable explanation in case of an error. 
}

/// The client can discover how notifications are setup.
message DiscoverParameterNotifications {
  repeated uint32 parameter_ids = 1;            ///< An array of parameter ID's to be queried for notification.  Leave Empty to Retrieve All
}

/// Reports which notifications are enabled.
message DiscoverParameterNotificationsResponse {
  repeated ParameterNotifyConfig configs = 1;    ///< An array of parameter notification configurations containing information only on parameters that have notifications enabled.
}

/// A message of this type is sent by the server when parameters change.
message ParameterNotification {
  repeated ParameterValue values     = 2;        ///< An array of parameter values containing those that changed.
}

/// These are the types of data that can be stored as parameters.
enum ParameterDataType {
  UINT32                  = 0;  ///< Unsigned 32 bit integer.
  INT32                   = 1;  ///< Signed 32 bit integer.
  FLOAT32                 = 2;  ///< 32 bit floating point.
  UINT64                  = 3;  ///< Unsigned 64 bit integer.
  INT64                   = 4;  ///< Signed 64 bit integer.
  FLOAT64                 = 5;  ///< 64 bit floating point.
  BOOL                    = 6;  ///< boolean (0 or 1)
  STRING                  = 7;  ///< ASCII or UTF-8. Null Terminated.
  ENUMERATION             = 8;  ///< An extended description gives names to 32 bit integer values.
  BIT_FIELD               = 9;  ///< An extended description gives names to up to 64 bit positions.
  BYTE_ARRAY              = 10; ///< An array of bytes.
}

/// A message used to send or receive a single parameter value.
message ParameterValue {
  uint32 parameter_id       = 1;  ///< The integer ID of this parameter.
  uint32 timestamp          = 2;  ///< The time at which this was last read or written.  Used for notifications.
  oneof value                     ///< A union is used to conventiently describe parameters in limited space.
  {                         
    uint32 uint32_value     = 3;  ///< Unsigned 32 bit integer.                                      
    sint32  int32_value     = 4;  ///< Signed 32 bit integer.                                        
    float  float32_value    = 5;  ///< 32 bit floating point.                                        
    uint64 uint64_value     = 6;  ///< Unsigned 64 bit integer.                                      
    sint64 int64_value     = 7;  ///< Signed 64 bit integer.                                        
    double float64_value    = 8;  ///< 64 bit floating point.                                        
    bool   bool_value       = 9;  ///< boolean (0 or 1)                                              
    string string_value     = 10; ///< ASCII or UTF-8. Null Terminated.                              
    uint32 enum_value       = 11; ///< An extended description gives names to 32 bit integer values. 
    uint64 bitfield_value   = 12; ///< An extended description gives names to up to 64 bit positions.
    bytes  bytes_value      = 13; ///< An array of bytes.                                            
  }                               
}

/// The optional file service provides a method of efficiently transfering large blocks of data.
message DiscoverFiles { }

/// The response to discover files
message DiscoverFilesResponse {
  repeated FileInfo file_infos = 1; ///< An array of File Info structures
}

/// A structure describing a file
message FileInfo {
  uint32 file_id                      = 1;  ///< ID by which this file is referenced
  string file_name                    = 2;  ///< Human readable file name
  AccessLevel access                  = 3;  ///< Access Level (Read / Write)
  int32 current_size_bytes            = 4;  ///< size in bytes
  optional uint32 maximum_size_bytes  = 7;  ///< Determined by storage space
  StorageLocation storage_location    = 5;  ///< NVM or RAM
  bool require_checksum               = 6;  ///< set true to request checksum generation and validation.
}

/// Begins a File Transfer (Upload / Download)
message FileTransferRequest {
  reserved 6;  // obsolete messages_per_ack
  uint32 file_id                      = 1;  ///< ID by which this file is referenced
  uint32 read_write                   = 2;  ///< 0 for read, 1 for write.
  uint32 request_offset               = 3;  ///< where to access in the file, in bytes
  uint32 transfer_length              = 4;  ///< number of bytes to read or write
  uint32 transfer_id                  = 5;  ///< Copied from the header, the same for the continuued transfer.
  uint32 timeout_in_ms                = 7;  ///< ms before abandonment
  optional uint32 requested_ack_rate  = 8;  ///< number of messages before ACK.
  bool   require_checksum             = 9;  ///< set true to enable checksum generation and validation.
}                                           

/// The response to a file transfer request
message FileTransferResponse {
  int32  result                       = 1;  ///< 0 if OK
  uint32 transfer_id                  = 2;  ///< Echos the request.
  uint32 ack_rate                     = 3;  ///< confirms or overrides request
  optional string result_message      = 4;  ///< In case of error, a human readable explanation.
  uint32 transfer_length              = 5;  ///< If the file is smaller than the requested offset + length, this will reflect how much data can be transferred
}                                           

/// A bidirectional message describing a packet of file data                  
message FileTransferData {
  int32  result                       = 1;  ///< non-zero for error
  uint32 transfer_id                  = 2;  ///< Unchanged during the continuued transfer.
  uint32 message_number               = 3;  ///< counts up from 1 in the first transfer
  bytes  message_data                 = 4;  ///< Data
  optional int32 checksum             = 5;  ///< Optional RFC 1071 checksum for integrity checking
}                                           

/// The response to a file transfer
message FileTransferDataNotification {
  int32  result                       = 1;  ///< 0 for success
  optional string result_message      = 2;  ///< Provides more information if an error occurs.
  bool   is_complete                  = 3;  ///< Set to true when all data has been trasnferred.
  uint32 transfer_id                  = 4;  ///< Unchanged during the continuued transfer.
  uint32 retry_offset                 = 5;  ///< If there is an error, this gives the offset at which a new transfer should start with good data.
}

/// A request to erase (set size to zero) a file.
message FileEraseRequest {
  uint32 file_id                      = 1;  ///< File ID to be erased
}                                           

/// The response to a file erase request
message FileEraseResponse {
  uint32 file_id                      = 1;  ///< File ID that has been erased
  int32  result                       = 2;  ///< 0 on success
  optional string result_message      = 3;  ///< Provides more information if an error occurs.
}

/// A request to list the streams supported by the device
message DiscoverStreams {}

/// The response to DiscoverStreams
message DiscoverStreamsResponse {
  repeated StreamInfo streams = 1;  ///< An array containing descriptions of the supported streams
}

/// A structure describing a stream
message StreamInfo {
  int32 stream_id             = 1;  ///< The ID by which this stream is addressed.
  AccessLevel access          = 2;  ///< Access Level for Stream  (Read / Write).
  string name                 = 3;  ///< A human readable name for this stream.
}

/// A structure requesting to open a stream
message StreamOpen {
  int32 stream_id             = 1;  ///< The ID by which this stream is addressed.
  AccessLevel access          = 2;  ///< Read or write access
}

/// The response to a StreamOpen request
message StreamOpenResponse {
    int32 stream_id                 = 1;  ///< The ID by which this stream is addressed.
    int32 result                    = 2;  ///< A result of zero indicates OK                                       
    optional string result_message  = 3;  ///< Allows to provide a human readable explanation in case of an error. 
}

/// A structure requesting to close a stream
message StreamClose {
    int32 stream_id           = 1;    ///< The ID by which this stream is addressed. 
}

/// Bi-Directional message used to asynchronously send stream data to the other side.
message StreamData {
  int32 stream_id             = 1;  ///< The ID by which this stream is addressed.
  uint32 roll_count           = 2;  ///< Message Number.  Increases with each send.  As stream transmission may be less relaible, allows for continuity checking.
  bytes message_data          = 3;  ///< An array of bytes representing the streami data.
  optional int32 checksum     = 4;  ///< Optional RFC 1071 checksum for integrity checking
}

/// The (optional) Command Service allows actions to be triggered from the Reach UI.
message DiscoverCommands {}                    ///< Request a list of supported commands.

/// Response to a DiscoverCommands request.
message DiscoverCommandsResponse {
  repeated CommandInfo available_commands = 1; ///< An array of command descriptions.
}

/// The description of a command.
message CommandInfo {
  uint32 id                   = 1;    ///< The id by which the command is dispatched
  string name                 = 2;    ///< Human readable descriptive name
  optional string description = 3;    ///< Optional longer description of the command
  optional uint32 timeout     = 4;    ///< Optional command timeout, in milliseconds, to account for slow commands.
}

/// Prompts the device to execute this command.
message SendCommand { 
  uint32 command_id = 1;  ///< The ID of the command to execute.
}

/// A response acknowledging the completion of a command.
message SendCommandResponse {
  int32 result                   = 1;      ///< A result of zero indicates OK                                       
  optional string result_message = 2;      ///< Allows to provide a human readable explanation in case of an error. 
}

/// The optional Command Line Interface (CLI) service allows command line messages to be transfered
/// between the client and the server.  Messages can travel in both directions.  Messages are asynchronous.
/// The client can send a command line and the server can respond.
/// The server can also asynchrously send strings representing the output of the device. 
/// The CLIData message is used in both directions.
message CLIData {
  string message_data = 1;  ///< The command line as a null terminated string.
}

/// The optional Time Service is designed to allow the client to 
/// set and adjust the real time clock in a server device.
/// The time is best specified as UTC plus timezone offset.
/// Although the timezone is optional, it's best to use it.
/// TimeSetRequest requests setting the server device time to this value.
message TimeSetRequest {
  int64   seconds_utc       = 1;  ///< linux epoch, since 1970
  optional int32  timezone  = 2;  ///< An adjustmeent in seconds to UTC time respresenting the local timezone.
}

/// The response to the TimeSetRequest
message TimeSetResponse {
  int32 result                   = 1;   ///< A result of zero indicates OK                                       
  optional string result_message = 2;   ///< Allows to provide a human readable explanation in case of an error. 
}

/// A request to read the time from the server.
message TimeGetRequest {}

/// The response to a TimeGetRequest
message TimeGetResponse {
  int32 result                   = 1;   ///< A result of zero indicates OK                                       
  optional string result_message = 2;   ///< Allows to provide a human readable explanation in case of an error. 
  int64   seconds_utc            = 3;   ///< linux epoch, since 1970                                                
  optional int32  timezone       = 4;   ///< An adjustmeent in seconds to UTC time respresenting the local timezone.
}

/// A structure describing a WiFi connection or access point
/// The optional WiFi service is intended to simplify the 
/// repetitive task of communicating WiFi credentials to the device.
message ConnectionDescription {
  string ssid                       = 1;  ///< The SSID of this connection
  bool is_connected                 = 2;  ///< true if connected
  optional int32  signal_strength   = 3;  ///< The strength of this connection in dB (RSSI)
  optional WiFiSecurity sec         = 4;  ///< The type of security used by this connection  
  optional WiFiBand band            = 5;  ///< The RF band used by this connection
}

/// Commands the server to initiate a scan for WiFi access points.
/// As this may take some time, issue it and check the response later.
message ScanWiFi { }                      

/// A request to provide a list access points
message DiscoverWiFi { }

/// response to DiscoverWiFi
message DiscoverWiFiResponse {
  bool scan_is_valid                = 1;   ///< true if a recent scan is complete.
  repeated ConnectionDescription cd = 2;   ///< An array of available access points
}

/// A structure describing a WiFi connection request
message WiFiConnectionRequest {
  string ssid                       = 1;  ///< The SSID to be addressed
  bool connect                      = 2;  ///< connect and disconnect false to get info on this SSID
  bool disconnect                   = 3;  ///< connect and disconnect false to get info on this SSID
  optional string password          = 4;  ///< required to connect
  optional bool autoconnect         = 5;  ///< true to remember and autoconnect to this AP.
}

/// Describes the response to a WiFi connection request
message WiFiConnectionResponse {
  int32 result                      = 1;  ///< A result of zero indicates OK                                      
  optional string result_message    = 3;  ///< Allows to provide a human readable explanation in case of an error.
  optional int32 signal_strength    = 2;  ///< RSSI
}

/// permissions
enum AccessLevel {
  NO_ACCESS   = 0;  ///< No permission
  READ        = 1;  ///< Read permission
  WRITE       = 2;  ///< Write permission
  READ_WRITE  = 3;  ///< Read and write permission
}

/// The types of memory in which parameters are stored.  RAM and NVM (Non Volatile Memory) are most common.
enum StorageLocation {
  STORAGE_LOCATION_INVALID  = 0;  ///< unknown, not used
  RAM                       = 1;  ///< RAM, volatile, not saved on reboot.
  NONVOLATILE               = 2;  ///< Flash or some other method saved over reboot
  RAM_EXTENDED              = 3;  ///< In case a device has two RAM locations
  NONVOLATILE_EXTENDED      = 4;  ///< In case a device has two non volatile locations
}

/// WiFi security type
enum WiFiSecurity {
  OPEN = 0;     ///< No security
  WEP  = 1;     ///< WEP
  WPA  = 2;     ///< WPA
  WPA2 = 3;     ///< WPA2
  WPA3 = 4;     ///< WPA3
}

/// WiFi Band
enum WiFiBand {
  NO_BAND = 0;  ///< Not specified
  BAND_2  = 2;  ///< 2.4GHz
  BAND_5  = 5;  ///< 5GHz
}

/// Reach uses these error codes.
enum ErrorCodes {
    NO_ERROR           = 0;  ///< Normal conclusion, no problem.
    NO_DATA            = 1;  ///< No data was produced
    READ_FAILED        = 2;  ///< The read failed.
    WRITE_FAILED       = 3;  ///< The write failed.
    NOT_IMPLEMENTED    = 4;  ///< returned by weak implementations
    RESERVED_1         = 5;  ///< not yet used
    RESERVED_2         = 6;  ///< not yet used
    PERMISSION_DENIED  = 7;  ///< access not allowed
    BUFFER_TOO_SMALL   = 8;  ///< Requested a size larger than the buffer.
    INVALID_PARAMETER  = 9;  ///< Some function parameter is out of range
    CHECKSUM_MISMATCH  = 10; ///< Received data does not match checksum
    DECODING_FAILED    = 11; ///< Protobuf decoding failed
    ENCODING_FAILED    = 12; ///< Protobuf encoding failed
    INVALID_STATE      = 13; ///< The current state machine does not handle this case.
    NO_RESPONSE        = 14; ///< handler signals no response is necessary
    BAD_FILE           = 15; ///< bad file ID
    PACKET_COUNT_ERR   = 16; ///< A received packet has an unexpected serial number
    CHALLENGE_FAILED   = 17; ///< Access denied due to challenge key
    RESERVED_3         = 18; ///< not yet used
    NO_RESOURCE        = 19; ///< Some required resource is not available.
    INVALID_ID         = 20;  ///< The ID provided is not valid
    ABORT              = 1000; ///< Operation cancellation
}

/// Describes file transfer state machine
enum FileTransferState {
    FILE_TRANSFER_INVALID = 0;  ///< FILE_TRANSFER_INVALID
    IDLE                  = 1;  ///< IDLE                 
    INIT                  = 2;  ///< INIT                 
    DATA                  = 3;  ///< DATA                 
    COMPLETE              = 4;  ///< COMPLETE             
}

/// This data describing the sizes of the structures used in C code is 
/// communicated in a packed format in the device info structure.  
/// Here it's defined in an unpacked (all 32 bit) format.  Use the offsets 
/// defined below (SizesOffsets) to unpack into this structure.
/// The file "reach_ble_proto_sizes.h" and the function 
/// populate_device_info_sizes() are good places to look for further info.
message BufferSizes {
    /// The largest message that can be communicated (16 bits)
    uint32  max_message_size             = 1;
    /// The size of the buffer used for the longest strings. (16 bits) 
    /// Examples include the command line and the error string.
    uint32  big_data_buffer_size         = 2;
    /// The number of parameter buffers kept by the device.
    /// This determines the number of parameters that can be
    /// handled in a single message. (8 bits)
    uint32  parameter_buffer_count       = 3;

    /// num_medium_structs_in_msg is replaced with more descriptive names.
    /// device_info_len is replaced with more descriptive names.

    /// The number of parameter values that fit in one message. (8 bits)
    uint32  num_params_in_response       = 4;
    /// The length of the description fields in various structures
    /// Previously known as long_string_len.   (8 bits)
    uint32  description_len              = 6;
    /// The number of bytes in the largest parameter data.  (8 bits)
    uint32  max_param_bytes              = 7;
    /// The number of bytes in the param info description string  (8 bits)
    uint32  param_info_description_len   = 10;
    /// The length of most (medium) strings.  (8 bits)
    /// Used for device name, file names, command names.
    uint32  medium_string_len            = 8;
    /// The number of bytes in short strings like the units label.  (8 bits)
    /// Also the names of enumerations and the version string.
    uint32  short_string_len             = 9;

    /// number of descriptors (stream, file) that fit in one message.  (8 bits)
    uint32  num_descriptors_in_response  = 5;
    /// Number of parameter notifications supported  (8 bits)
    uint32  num_param_notifications      = 11;
    /// not currently used  (8 bits)
    uint32  num_commands_in_response     = 13;
    /// number of param descriptions that can be in one info packet. (8 bits)
    uint32  count_param_desc_in_response = 14;
    /// The max number of parameter notification configurations 
    /// that a client will provide. 
    uint32  param_notify_config_count    = 15;
}

/// This describes the offset of each member of the BufferSizes message when packed for transmission 
enum SizesOffsets {
    MAX_MESSAGE_SIZE_OFFSET              = 0;   ///< uint16_t, little endian
    BIG_DATA_BUFFER_SIZE_OFFSET          = 2;   ///< uint16_t, little endian
    PARAMETER_BUFFER_COUNT_OFFSET        = 4;   ///< uint8_t
    NUM_PARAMS_IN_RESPONSE_OFFSET        = 5;   ///< uint8_t
    DESCRIPTION_LEN_OFFSET               = 6;   ///< uint8_t
    MAX_PARAM_BYTES_OFFSET               = 7;   ///< uint8_t
    PARAM_INFO_DESCRIPTION_LEN_OFFSET    = 8;   ///< uint8_t
    MEDIUM_STRING_LEN_OFFSET             = 9;   ///< uint8_t
    SHORT_STRING_LEN_OFFSET              = 10;  ///< uint8_t
    PARAM_NOTIFY_CONFIG_COUNT_OFFSET     = 11;  ///< uint8_t
    NUM_DESCRIPTORS_IN_RESPONSE_OFFSET   = 12;  ///< uint8_t
    NUM_PARAM_NOTIFICATIONS_OFFSET       = 13;  ///< uint8_t
    NUM_COMMANDS_IN_RESPONSE_OFFSET      = 14;  ///< uint8_t
    COUNT_PARAM_DESC_IN_RESPONSE_OFFSET  = 15;  ///< uint8_t
    STRUCTURE_SIZE                       = 16;  ///< just the size
}

