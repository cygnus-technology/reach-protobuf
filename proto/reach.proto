// A very simple protocol definition, consisting of only
// one message.

syntax = "proto3";
import "services.proto";

package cr;

message ReachTransportIDs {
  enum Ids {
    INVALID = 0;         // No Valid Message
    PING = 1;            // ping / ping~
    GET_DEVICE_INFO = 2; // gdi / gdi~

    // Parameters
    DISCOVER_PARAMETERS = 3; // dp / dp~
    READ_PARAMETERS = 4;     // rp / rp~
    WRITE_PARAMETERS = 5;    // wp / wp~
    NOTIFY_PARAMETERS = 6;   // pnr/ pnr~

    // File Transfers
    DISCOVER_FILES = 7; // gfd / gfd~
    TRANSFER_INIT = 8;  // Begins a Transfer
    TRANSFER_DATA = 9;  // Sends Data
    TRANSFER_DATA_NOTIFICATION =
        10; // Clears Sender (Client / Service) to Send More Data

    // Draft
    DISCOVER_STREAMS = 11;         // gsd / gsd~
    MANAGE_STREAM = 12;            // gsd / gsd~
    STREAM_DATA_NOTIFICATION = 13; // stream-

    DISCOVER_COMMANDS = 14; // gcd / gcd~
    SEND_COMMAND = 15;      // sc / sc~
  }
}

// Request Object used to Echo Data for testing the Device Communication
message PingRequest {
  bytes echo_data = 1; // d : Data
}

// Response Object used to Echo Data for testing the Device Communication
message PingResponse {
  bytes echo_data = 1; // d : Data
  uint32 signal_strength =
      2; // rssi : Rssi express in strength so clients don't have to interepret
}

// ------------------------------------------------------
// Device Information Request / Resposne
// // gdi : gdi~
// ------------------------------------------------------
message DeviceInfoRequest {
  // (Optional) Value to Display Prior to Sharing Device Info.
  // if not accepted, Message Result will Return False.
  //
  // Used when native transport does not include security features and local
  // verification is needed.
  uint32 challenge_key = 1;
}

message DeviceInfoResponse {
  MessageResult result = 1;      // err~ : Replaces Error Result
  int32 protocol_version = 3;    // pv : Supported Protocol Version
  string device_name = 4;        // n : Name, Typically Model Name
  string device_description = 5; // d : Decription

  // TODO: Temporarily replace map with the string until we can figure out how
  // to handle this
  // map<string, string> version_info = 6; // fw : Replaces Firmware Version
  string firmware_version = 6; // fw : Replaces Firmware Version

  uint32 max_message_size = 7; // mml : Max Message Length
  // repeated string service_list = 8;   // svc : List of Supported Services
  uint32 parameter_metadata_hash = 9; // hash : Parameter Metadata Hash
  bytes application_indentifier = 10; // uuid : Custom UI Remote Key

  // TODO: Temporarily removed map until we can figure out how
  // to handle this
  // map<uint32, string> available_endpoints =
  //     11; // ep : EndPoints - Returns a list of endpoints available on this
  // Gateway
}

// ------------------------------------------------------
// Discover ParameterInfo
// // dp / dp~
// ------------------------------------------------------
message ParameterInfoRequest {
  uint32 parameter_key = 1;          // Unlock Key
  repeated uint32 parameter_ids = 2; // i: ID's to Fetch (Empty to Get All)
}

message ParameterInfoResponse {
  repeated ParameterInfo parameter_infos = 1; // Array of Param Infos
}

message ParameterInfo {
  uint32 id = 1;                   // i: Id
  ParameterDataType data_type = 2; // t: DataType
  uint32 size_in_bytes = 3;        // l: Byte Length for Variable Length Items.
  string name = 4;                 // n: Name
  AccessLevel access = 5;          // a: Access
  string description = 6; // d: Description - Suggestion - Move this to a UI
                          // Specific Type Extension Object?
  string unit = 7;        // u: Units
  double range_min = 8;   // rmi: Range Max
  double range_max = 9;   // rma: Range Max
  double default_value =
      10; //		Suggestion - Show instead of value if no value.
  StorageLocation storage_location = 11; // s: Storage Location
  // map<uint32, string> enumeration_values =
  //     12; // map: Array of Enumeration Values
}

// ------------------------------------------------------
// Parameter Reads
// // rp : rp~
// ------------------------------------------------------
message ParameterRead {
  uint32 parameter_key = 1;          //		Suggestion: Optional Key for Unlocking
                                     // Private Parameters
  repeated uint32 parameter_ids = 2; // i: ID -  Leave Empty to Retreive All
  uint32 read_after_timestamp =
      3; // Allows for retreival of only new / changed values.
}

message ParameterReadResult {
  MessageResult result = 1;  // err~
  uint32 read_timestamp = 2; // Returns timestamp of last read...usefull for
                             // polling large variable lists.
  repeated ParameterValue values = 3; // Array of Result Values
}

// ------------------------------------------------------
// Parameter Writes
// // wp : wp~
// ------------------------------------------------------
message ParameterWrite {
  uint32 parameter_key =
      1; // Suggestion: Optional Key for Unlocking Private Parameters
  repeated ParameterValue values = 3; // Array of Write Values
}

message ParameterWriteResult {
  MessageResult result = 1; // err~
}

// ------------------------------------------------------
// Parameter Notification Registration
// // pnr : pnr~
// ------------------------------------------------------
message ParameterNotify {
  uint32 parameter_key =
      1;            // Suggestion: Optional Key for Unlocking Private Parameters
  bool enabled = 2; // Enabled or Disabled
  repeated uint32 parameter_ids = 3; // i: ID -  Leave Empty to Retreive All
  uint32 mininum_notification_period =
      4; // min_ms: Minimum Notification Interval (ms)
  uint32 maximum_notification_period =
      5; // max_ms: Minimum Notification Interval (ms)
}

// ------------------------------------------------------
// Parameter Notification
// // pn : pn~
// ------------------------------------------------------
message ParameterNotification {
  uint32 parameter_key =
      1; // Suggestion: Optional Key for Unlocking Private Parameters
  repeated ParameterValue values = 2; // Array of Result Values
}

message ParameterNotifyResult {
  MessageResult result = 1;                  // err~
  repeated ParameterValue failed_values = 3; // Array of Write Values
}

// --------------------------------------------------------
// Message for Sending / Recieving a Single Parameter Value
// Uses OnOf (Union) for Values
// --------------------------------------------------------
message ParameterValue {
  uint32 parameter_id = 1; // i: ID
  oneof value              // v: Typed Values Union
  {
    sint32 sint_value = 2;   // Int / Uint / BitField   Signed
    uint32 uint_value = 3;   // Int / Uint / BitField
    double float_value = 4;  // Float
    string string_value = 5; // String Values (UTF8?)
    bytes data_value = 6;    // Byte Array Values

    // TODO - Added bool for testing, to be finalized
    bool bool_value = 7; // Bool
  }
  uint32 timestamp = 8; // ts: Time Stamp for Notification
}

// ------------------------------------------------------
// Discover Files
// // gfd : gfd~
// ------------------------------------------------------
message DiscoverFiles { StorageLocation storage_location = 1; }

message DiscoverFilesReply {
  repeated FileInfo file_infos = 1; // Array of File Infos
}

message FileInfo {
  int32 file_id = 1;      // i: ID
  string file_name = 2;   // n: Name
  AccessLevel access = 3; // a: Access Level (Read / Write)
  int32 current_size_bytes =
      4; // l: size in bytes (currently...may change over time.
}

// ------------------------------------------------------
// Begins a File Transfer (Upload / Download)
// ------------------------------------------------------
message TransferInit {

  // TODO: Change file id to int32 to make it consistent with
  // DiscoveryFilesReply/FileInfo Ahsoha message for testing, to be finalized
  int32 file_id = 1; // i: File ID
  // string file_id = 1; // i: File ID
  int32 timeout_in_ms =
      2; // Time afterwhich the Reciever (Client / Service) should abandon the
         // transfer abandoned due to after inactivity.
  uint32 request_offset =
      3; // o: Offset Into "File" to Read / Write used for Reading / Writing a
         // partial file or restarting a transfer
  uint32 transfer_length =
      4; //	  Length of file requested for partial reads / writes
  FileTransferType file_transfer_type = 5; // Direction of Transfer
}

message TransferInitReply {
  MessageResult result = 1; // err~
  int32 transfer_id = 2;    // Service Sends a TansferID that will be used to
                            // manage this specific transfer.
  int32 max_bytes_per_message =
      3; // Service Communicates the Max Size of Messages.
}

// Bi-Directional Message
message TransferData {
  int32 transfer_id = 1; // Transfer ID
  uint32 message_number =
      2; // Message Number (Message Number used for Roll Counting and Batching)
  bytes message_data = 3; // Data
  int32 crc32 = 4; // Optional crc for integrity checking when native transport
                   // doesn't ensure integrity (most do so mostly serial data)
}

message TransferDataNotification {
  MessageResult result = 1; // err~
  int32 transfer_id = 2;
  uint32 messages_to_send =
      3; // Returns number of messages that are clear to send.
  uint32 bytes_transfered =
      4; // Note that this MAY be < has been Sent...Information Only.
  bool is_complete = 5;
}

// ------------------------------------------------------
// Discovery Streams Request and Response
//		Returns a list of StreamID & Descriptions available on this
// endpoint
// ------------------------------------------------------
message StreamsRequest {}

message StreamsResponse { repeated StreamInfo streams = 1; }

message StreamInfo {
  int32 stream_id = 1;
  AccessLevel access = 2; // Access Level for Stream  Read / Write.
  string name = 3;        // Name of Stream / CLI.
  int32 max_bytes_per_message = 4; // Max Size of Messages.
}

message StreamOpen {
  int32 stream_id = 1;    // Stream ID
  AccessLevel access = 2; // Read or Write.
}

message StreamOpenReply {
    int32 stream_id = 1;    // Stream ID
    MessageResult result = 2; // Carries Success / Result
}

message StreamClose {
    int32 stream_id = 1;    // Stream ID
}

// Bi-Directional Message
message StreamData {
  int32 stream_id = 1;    // Stream ID
  uint32 roll_count = 2;  // Message Number (Roll Count)
  bytes message_data = 3; // Data
  int32 crc32 = 4; // Optional crc for integrity checking when native transport
                   // doesn't ensure integrity (most do so mostly serial data)
}

// ------------------------------------------------------
// Discover Commands
// // gcd : gcd~
// ------------------------------------------------------
message DiscoverCommands {}

message DiscoverCommandsResult {
  repeated CommandInfo available_commands = 1; // Array of v:n    Values : Names
}

// TODO: Add CommandInfo for testing, to be finalized
message CommandInfo {
  uint32 id = 1;                   // i: Id
  string name = 2;                 // n: Name
}

// ------------------------------------------------------
// Send Command
// // sc : sc~
// ------------------------------------------------------
message SendCommand { uint32 command = 1; }

message SendCommandResult {
  MessageResult result = 1; // Carries Success / Result
}

// ------------------------------------------------------
// Result Structure used by all Messages for Returning Errors. err~
// ------------------------------------------------------
message MessageResult {
  bool result_value = 1;    // Error Result
  string result_string = 2; // Error String
}

enum ParameterDataType {
  parameter_type_invalid = 0;
  uint32 = 1;
  int32 = 2;
  float = 3;
  bool = 4;
  string = 5; // QUESTIONS - ASCII??? No UTF-8?  Null Terminated?
  enumeration = 6;
  bit_field = 7;
  byte_array = 8;
}

enum StreamType {
  stream_type_invalid = 0;
  stream_binary = 1;
  stream_string = 2;
}

enum StreamCommands {
  command_invalid = 0;
  start = 1;
  stop = 2;
}

enum StreamState {
  stopped = 0;
  starting = 1;
  stopping = 2;
}

enum AccessLevel {
  read = 0;
  write = 1;
}

enum FileTransferType {
  client_upload = 0;
  client_download = 1;
}

enum StorageLocation {
  storage_location_invalid = 0;
  ram = 1;
  nonvolitile = 2;
  ram_extended = 3;
  nonvolitile_extended = 4;
}

// TODO: Reach message for testing, to be finalized
message AhsokaMessage {
  AhsokaServiceFramework.AhsokaMessageHeader header = 1;
  bytes payload = 2;
}

// TODO: File tranfer state machine for testing, to be finalized
// enum FileTransferState {
//   invalid = 0;
//   idle = 1;
//   init = 2;
//   data = 3;
//   complete = 4;
// }

// message FileTransferStateMachine {
//   FileTransferState state = 1;
//   int32 transfer_id = 2;
//   int32 file_id = 3;
//   int32 timeout_in_ms = 4;
//   uint32 request_offset = 5;
//   uint32 transfer_length = 6;
//   FileTransferType file_transfer_type = 7;
//   uint32 message_number = 8;
//   bytes message_data = 9;
//   int32 crc32 = 10;
//   uint32 messages_to_send = 11;
//   uint32 bytes_transfered = 12;
//   bool is_complete = 13;
//   int32 max_bytes_per_message = 14;
// }